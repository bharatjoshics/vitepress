import{_ as t,c as o,o as p,ae as r}from"./chunks/framework.BmN8lrCQ.js";const u=JSON.parse('{"title":"Computed Properties","description":"","frontmatter":{},"headers":[],"relativePath":"computed-properties.md","filePath":"computed-properties.md"}'),a={name:"computed-properties.md"};function n(s,e,i,d,c,m){return p(),o("div",null,e[0]||(e[0]=[r('<h1 id="computed-properties" tabindex="-1">Computed Properties <a class="header-anchor" href="#computed-properties" aria-label="Permalink to &quot;Computed Properties&quot;">​</a></h1><p>Computed properties are like data properties, except they depend on other properties.</p><p>They are written like methods, but they do not accept any input arguments.</p><p>They are used when outputting something that depends on something else.</p><p>A computed property automatically tracks its reactive dependencies.</p><h2 id="important" tabindex="-1">Important <a class="header-anchor" href="#important" aria-label="Permalink to &quot;Important&quot;">​</a></h2><p>Instead of computed properties, we can define the same function as a method. For the end result, the two approaches are indeed exactly the same.</p><p>However, a computed property will only re-evaluate when some if its reactive dependencies have changed.</p><p>We don&#39;t need to use parentheses &#39;()&#39; while calling the computed property.</p><p><strong>It is more efficient than methods</strong></p>',10)]))}const l=t(a,[["render",n]]);export{u as __pageData,l as default};
